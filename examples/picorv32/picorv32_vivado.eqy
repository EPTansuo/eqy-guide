##############################################################
#
# Gold: Modified PicoRV32 Verilog HDL
# Gate: Synthesis Output from Xilinx Vivado

[gold]
read_verilog picorv32_modified.v
read_verilog init.v
prep -top testbench

[gate]
logger -nowarn limited.support.for.tri-state.*/cells_sim.v
read_verilog -nowb -noblackbox +/xilinx/cells_sim.v
read_verilog picorv32_vivado.v
read_verilog init.v
prep -top testbench

rename -hide t:GND t:VCC t:OBUF t:IBUF t:BUFG t:FDRE t:FDSE
flatten t:GND t:VCC t:OBUF t:IBUF t:BUFG t:FDRE t:FDSE
rename -hide w:*BUF*

setattr -mod -set unique 1 picorv32
uniquify t:RAM32X1D t:RAM32M
opt -noff -keepdc -fast
hierarchy

[script]
sim -w -vcd init_gate.vcd -clock clk -resetn resetn -n 100
hierarchy -top picorv32


##############################################################
#
# Delete unused outputs

[gold]
cd picorv32
delete -output mem_la_* trace_* pcpi_* eoi
rename -hide mem_la_* trace_* eoi

[gate]
cd picorv32
delete -output mem_la_* trace_* pcpi_* eoi
rename -hide mem_la_* trace_* eoi

##############################################################
#
# Split some fiddly nets on either side

[gold]
splitnets cpu_state
splitnets alu_out
splitnets count_instr
splitnets mem_rdata_latched
splitnets reg_next_pc
splitnets decoded_imm_j
cd ..

[gate]
splitnets cpu_state0_out
splitnets decoded_imm_j
cd ..

[collect picorv32]
group alu_out[]
group decoded_imm_j[]

##############################################################
#
# Purge X-bits and other cleanups

[gold]
setundef -zero -undriven -init
opt -fine -keepdc -fast
memory_map
splitcells
clean

[gate]
setundef -zero -undriven -init
opt -keepdc -fast
clean

##############################################################
#
# PicoRV32 Register File Outputs

[match picorv32]
gold-match pcpi_rs[12]

[collect picorv32]
solo-group pcpi_rs[12]


##############################################################
#
# Vivado weirdly renames the CPU state FSM register:
#     cpu_state0_out[*]       the value before the FF, i.e. the next state
#     cpu_state_reg_n_0_[*]   the value after the FF, i.e. cpu_state
# except bits 4 and 6, as bit 4 encodes the unused "ld_rs2" state, and
# bit 6 (encoding for "fetch") ended up as 1-bit reg_next_pc wire.

[match picorv32]
gold-match cpu_state[0] cpu_state_reg_n_0_[0]
gold-match cpu_state[1] cpu_state_reg_n_0_[1]
gold-match cpu_state[2] cpu_state_reg_n_0_[2]
gold-match cpu_state[3] cpu_state_reg_n_0_[3]
gold-match cpu_state[4] cpu_state0_out[4]
gold-match cpu_state[5] cpu_state_reg_n_0_[5]
gold-match cpu_state[6] reg_next_pc
gold-match cpu_state[7] cpu_state_reg_n_0_[7]

[collect picorv32]
solo-group cpu_state[]


##############################################################
#
# More Manual Matches
# .. identified via vcdmatch.py

[match picorv32]
gold-match alu_out[] alu_out_q[\2]_i_1_n_0
gold-match count_instr[] count_instr_reg_n_0_[\2]
gold-match reg_next_pc[] reg_next_pc_reg_n_0_[\2]

gold-match decoder_trigger        \0_reg_n_0
gold-match latched_is_lb          \0_reg_n_0
gold-match latched_is_lh          \0_reg_n_0
gold-match latched_stalu          \0_reg_n_0
gold-match latched_store          \0_reg_n_0
gold-match mem_do_prefetch        \0_reg_n_0

gold-match decoder_pseudo_trigger \0_reg_n_0
gold-match latched_branch         \0_reg_n_0
gold-match latched_is_lu          \0_reg_n_0
gold-match mem_do_rinst           \0_reg_n_0

gate-nomatch decoder_pseudo_trigger
gate-nomatch latched_branch
gate-nomatch latched_is_lu
gate-nomatch mem_do_rinst


##############################################################
#
# Additional False Equivalent Points
# .. identified via picorv32_vivado/modules/picorv32.sby

[match picorv32]
gate-nomatch mem_state
gate-nomatch mem_wordsize
gate-nomatch reg_out
gate-nomatch reg_op1
gate-nomatch reg_sh


##############################################################
#
# Partitioning and Strategies

[collect picorv32]
solo-join cpuregs_wrdata
solo-join decoded_*
solo-join /(instr|is)_.*/
solo-join latched_rd
solo-join mem_*
solo-join alu_*
solo-join pcpi_insn

[partition picorv32]

# currently passing pdr
merge is_*
merge alu_*
merge instr_*
merge count_*
final decoder_trigger
final decoder_pseudo_trigger
final pcpi_valid
final pcpi_insn
final trap

# currently failing pdr, but passing bmc
final cpuregs_wrdata
final reg_next_pc[]
final cpu_state[]
final pcpi_rs1
merge mem_*
merge decoded_*
merge latched_*

# amend some partitions
amend cpu_state[] count_*
amend cpu_state[] decoder_trigger
amend cpu_state[] trap

amend cpu_state[]      decoder_pseudo_trigger
amend mem_valid        decoder_pseudo_trigger
amend mem_do_*         decoder_pseudo_trigger
amend instr_*          decoder_pseudo_trigger
amend is_lbu_lhu_lw    decoder_pseudo_trigger
amend is_slti_blt_slt  decoder_pseudo_trigger
amend is_sltiu_bltu_*  decoder_pseudo_trigger
amend is_sll_srl_sra   decoder_pseudo_trigger
amend decoder_trigger  decoder_pseudo_trigger
amend latched_is_lb    decoder_pseudo_trigger
amend latched_is_lh    decoder_pseudo_trigger
amend latched_is_lu    decoder_pseudo_trigger


# amend templates
#
#amend cpu_state[]      XYZ
#amend mem_*            XYZ
#amend decode*          XYZ
#amend instr_*          XYZ
#amend is_*             XYZ
#amend alu*             XYZ
#amend count*           XYZ
#amend latch*           XYZ
#amend pcpi*            XYZ
#amend *reg*            XYZ
#amend trap             XYZ
#
#amend mem_addr         XYZ
#amend mem_instr        XYZ
#amend mem_valid        XYZ
#amend mem_wdata        XYZ
#amend mem_wstrb        XYZ
#amend mem_do_prefetch  XYZ
#amend mem_do_rdata     XYZ
#amend mem_do_rinst     XYZ
#amend mem_do_wdata     XYZ
#
#amend decoded_rd       XYZ
#amend decoded_rs1      XYZ
#amend decoded_imm_j[]  XYZ
#amend decoded_imm      XYZ
#amend decoder_pseudo*  XYZ
#amend decoder_trigger  XYZ
#
#amend instr_add        XYZ
#amend instr_addi       XYZ
#amend instr_and        XYZ
#amend instr_andi       XYZ
#amend instr_auipc      XYZ
#amend instr_beq        XYZ
#amend instr_bge        XYZ
#amend instr_bgeu       XYZ
#amend instr_blt        XYZ
#amend instr_bltu       XYZ
#amend instr_bne        XYZ
#amend instr_jal        XYZ
#amend instr_jalr       XYZ
#amend instr_lb         XYZ
#amend instr_lbu        XYZ
#amend instr_lh         XYZ
#amend instr_lhu        XYZ
#amend instr_lui        XYZ
#amend instr_lw         XYZ
#amend instr_or         XYZ
#amend instr_ori        XYZ
#amend instr_rdcycle    XYZ
#amend instr_rdcycleh   XYZ
#amend instr_rdinstr    XYZ
#amend instr_rdinstrh   XYZ
#amend instr_sb         XYZ
#amend instr_sh         XYZ
#amend instr_sll        XYZ
#amend instr_slli       XYZ
#amend instr_slt        XYZ
#amend instr_slti       XYZ
#amend instr_sltiu      XYZ
#amend instr_sltu       XYZ
#amend instr_sra        XYZ
#amend instr_srai       XYZ
#amend instr_srl        XYZ
#amend instr_srli       XYZ
#amend instr_sub        XYZ
#amend instr_sw         XYZ
#amend instr_xor        XYZ
#amend instr_xori       XYZ
#
#amend is_alu_reg_imm   XYZ
#amend is_alu_reg_reg   XYZ
#amend is_beq_bne_*     XYZ
#amend is_compare       XYZ
#amend is_jalr_addi_*   XYZ
#amend is_lb_lh_lw_*    XYZ
#amend is_lbu_lhu_lw    XYZ
#amend is_lui_auipc_jal XYZ
#amend is_lui_*_add_sub XYZ
#amend is_sb_sh_sw      XYZ
#amend is_sll_srl_sra   XYZ
#amend is_slli_srli_*   XYZ
#amend is_slti_blt_slt  XYZ
#amend is_sltiu_bltu_*  XYZ
#
#amend latched_rd       XYZ
#amend latched_branch   XYZ
#amend latched_stalu    XYZ
#amend latched_store    XYZ
#amend latched_is_lb    XYZ
#amend latched_is_lh    XYZ
#amend latched_is_lu    XYZ

[strategy pdr]
use sby
engine abc pdr
timeout 900

[strategy sby]
use sby
depth 8
engine smtbmc bitwuzla
